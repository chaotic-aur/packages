diff --git a/rpcs3/Emu/Cell/Modules/cellAtracXdec.cpp b/rpcs3/Emu/Cell/Modules/cellAtracXdec.cpp
index 36228d8a5e..c55cf7b60f 100644
--- a/rpcs3/Emu/Cell/Modules/cellAtracXdec.cpp
+++ b/rpcs3/Emu/Cell/Modules/cellAtracXdec.cpp
@@ -111,29 +111,6 @@ void AtracXdecDecoder::alloc_avcodec()
 		fmt::throw_exception("avcodec_find_decoder() failed");
 	}
 
-	ensure(!(codec->capabilities & AV_CODEC_CAP_SUBFRAMES));
-
-	ctx = avcodec_alloc_context3(codec);
-	if (!ctx)
-	{
-		fmt::throw_exception("avcodec_alloc_context3() failed");
-	}
-
-	// Allows FFmpeg to output directly into guest memory
-	ctx->opaque = this;
-	ctx->thread_type = FF_THREAD_SLICE; // Silences a warning by FFmpeg about requesting frame threading with a custom get_buffer2(). Default is FF_THREAD_FRAME & FF_THREAD_SLICE
-	ctx->get_buffer2 = [](AVCodecContext* s, AVFrame* frame, int /*flags*/) -> int
-	{
-		for (s32 i = 0; i < frame->ch_layout.nb_channels; i++)
-		{
-			frame->data[i] = static_cast<AtracXdecDecoder*>(s->opaque)->work_mem.get_ptr() + ATXDEC_MAX_FRAME_LENGTH + ATXDEC_SAMPLES_PER_FRAME * sizeof(f32) * i;
-			frame->linesize[i] = ATXDEC_SAMPLES_PER_FRAME * sizeof(f32);
-		}
-
-		frame->buf[0] = av_buffer_create(frame->data[0], ATXDEC_SAMPLES_PER_FRAME * sizeof(f32) * frame->ch_layout.nb_channels, [](void*, uint8_t*){}, nullptr, 0);
-		return 0;
-	};
-
 	packet = av_packet_alloc();
 	if (!packet)
 	{
@@ -149,18 +126,47 @@ void AtracXdecDecoder::alloc_avcodec()
 
 void AtracXdecDecoder::free_avcodec()
 {
-	av_packet_free(&packet);
-	av_frame_free(&frame);
-	avcodec_free_context(&ctx);
+	if (packet)
+	{
+		av_packet_free(&packet);
+	}
+	if (frame)
+	{
+		av_frame_free(&frame);
+	}
+	if (ctx)
+	{
+		avcodec_free_context(&ctx);
+	}
 }
 
 void AtracXdecDecoder::init_avcodec()
 {
-	if (int err = avcodec_close(ctx); err)
+	if (ctx)
+	{
+		avcodec_free_context(&ctx);
+	}
+
+	ctx = avcodec_alloc_context3(codec);
+	if (!ctx)
 	{
-		fmt::throw_exception("avcodec_close() failed (err=0x%x='%s')", err, utils::av_error_to_string(err));
+		fmt::throw_exception("avcodec_alloc_context3() failed");
 	}
 
+	// Allows FFmpeg to output directly into guest memory
+	ctx->opaque = this;
+	ctx->thread_type = FF_THREAD_SLICE; // Silences a warning by FFmpeg about requesting frame threading with a custom get_buffer2(). Default is FF_THREAD_FRAME & FF_THREAD_SLICE
+	ctx->get_buffer2 = [](AVCodecContext* s, AVFrame* frame, int /*flags*/) -> int
+	{
+		for (s32 i = 0; i < frame->ch_layout.nb_channels; i++)
+		{
+			frame->data[i] = static_cast<AtracXdecDecoder*>(s->opaque)->work_mem.get_ptr() + ATXDEC_MAX_FRAME_LENGTH + ATXDEC_SAMPLES_PER_FRAME * sizeof(f32) * i;
+			frame->linesize[i] = ATXDEC_SAMPLES_PER_FRAME * sizeof(f32);
+		}
+
+		frame->buf[0] = av_buffer_create(frame->data[0], ATXDEC_SAMPLES_PER_FRAME * sizeof(f32) * frame->ch_layout.nb_channels, [](void*, uint8_t*){}, nullptr, 0);
+		return 0;
+	};
 	ctx->block_align = nbytes;
 	ctx->ch_layout.nb_channels = nch_in;
 	ctx->sample_rate = sampling_freq;
diff --git a/rpcs3/Emu/Cell/Modules/cellAtracXdec.h b/rpcs3/Emu/Cell/Modules/cellAtracXdec.h
index a670a242c2..7fc5e49956 100644
--- a/rpcs3/Emu/Cell/Modules/cellAtracXdec.h
+++ b/rpcs3/Emu/Cell/Modules/cellAtracXdec.h
@@ -192,10 +192,10 @@ struct AtracXdecDecoder
 
 	// HLE exclusive
 	b8 config_is_set = false; // For savestates
-	const AVCodec* codec;
-	AVCodecContext* ctx;
-	AVPacket* packet;
-	AVFrame* frame;
+	const AVCodec* codec = nullptr;
+	AVCodecContext* ctx = nullptr;
+	AVPacket* packet = nullptr;
+	AVFrame* frame = nullptr;
 
 	u8 spurs_stuff[84]; // 120 bytes on LLE, pointers to CellSpurs, CellSpursTaskset, etc.
 
diff --git a/rpcs3/Emu/RSX/Common/simple_array.hpp b/rpcs3/Emu/RSX/Common/simple_array.hpp
index 033994547d..f11587a84b 100644
--- a/rpcs3/Emu/RSX/Common/simple_array.hpp
+++ b/rpcs3/Emu/RSX/Common/simple_array.hpp
@@ -173,7 +173,7 @@ namespace rsx
 			if (is_local_storage())
 			{
 				// Switch to heap storage
-				_data = static_cast<Ty*>(std::malloc(sizeof(Ty) * size));
+				ensure(_data = static_cast<Ty*>(std::malloc(sizeof(Ty) * size))); // "malloc() failed!"
 				std::memcpy(static_cast<void*>(_data), _local_storage, size_bytes());
 			}
 			else
diff --git a/rpcs3/Emu/RSX/Common/texture_cache_utils.h b/rpcs3/Emu/RSX/Common/texture_cache_utils.h
index 8c5defdd0b..8945cf0623 100644
--- a/rpcs3/Emu/RSX/Common/texture_cache_utils.h
+++ b/rpcs3/Emu/RSX/Common/texture_cache_utils.h
@@ -79,7 +79,7 @@ namespace rsx
 
 		private:
 			// Members
-			block_list *block;
+			block_list* block = nullptr;
 			list_iterator list_it = {};
 			size_type idx = u32{umax};
 			size_type array_idx = 0;
@@ -705,9 +705,9 @@ namespace rsx
 		private:
 			// Members
 			address_range32 range;
-			section_bounds bounds;
+			section_bounds bounds {};
 
-			block_type *block = nullptr;
+			block_type* block = nullptr;
 			bool needs_overlap_check = true;
 			bool unowned_remaining = false;
 			unowned_iterator unowned_it = {};
diff --git a/rpcs3/Emu/RSX/GL/GLRenderTargets.cpp b/rpcs3/Emu/RSX/GL/GLRenderTargets.cpp
index c222262699..af009014c4 100644
--- a/rpcs3/Emu/RSX/GL/GLRenderTargets.cpp
+++ b/rpcs3/Emu/RSX/GL/GLRenderTargets.cpp
@@ -218,7 +218,7 @@ void GLGSRender::init_buffers(rsx::framebuffer_creation_context context, bool /*
 		static_cast<gl::framebuffer_holder*>(m_draw_fbo)->release();
 	}
 
-	for (auto &fbo : m_framebuffer_cache)
+	for (auto& fbo : m_framebuffer_cache)
 	{
 		if (fbo.matches(color_targets, depth_stencil_target))
 		{
@@ -264,6 +264,8 @@ void GLGSRender::init_buffers(rsx::framebuffer_creation_context context, bool /*
 		}
 	}
 
+	ensure(m_draw_fbo);
+
 	switch (rsx::method_registers.surface_color_target())
 	{
 	case rsx::surface_target::none: break;
diff --git a/rpcs3/Emu/RSX/GL/GLTexture.cpp b/rpcs3/Emu/RSX/GL/GLTexture.cpp
index 0c34690bf4..4ed46e85a0 100644
--- a/rpcs3/Emu/RSX/GL/GLTexture.cpp
+++ b/rpcs3/Emu/RSX/GL/GLTexture.cpp
@@ -279,6 +279,8 @@ namespace gl
 	void* copy_image_to_buffer(gl::command_context& cmd, const pixel_buffer_layout& pack_info, const gl::texture* src, gl::buffer* dst,
 		u32 dst_offset, const int src_level, const coord3u& src_region,  image_memory_requirements* mem_info)
 	{
+		ensure(src && dst);
+
 		auto initialize_scratch_mem = [&]() -> bool // skip_transform
 		{
 			const u64 max_mem = (mem_info->memory_required) ? mem_info->memory_required : mem_info->image_size_in_bytes;
diff --git a/rpcs3/Emu/RSX/GL/glutils/program.h b/rpcs3/Emu/RSX/GL/glutils/program.h
index 72daef2523..5caca0ed98 100644
--- a/rpcs3/Emu/RSX/GL/glutils/program.h
+++ b/rpcs3/Emu/RSX/GL/glutils/program.h
@@ -14,7 +14,7 @@ namespace gl
 		class shader
 		{
 			std::string source;
-			::glsl::program_domain type;
+			::glsl::program_domain type {};
 			GLuint m_id = GL_NONE;
 
 			fence m_compiled_fence;
diff --git a/rpcs3/Emu/RSX/GL/glutils/state_tracker.hpp b/rpcs3/Emu/RSX/GL/glutils/state_tracker.hpp
index ffc4fe38f1..c5599f7756 100644
--- a/rpcs3/Emu/RSX/GL/glutils/state_tracker.hpp
+++ b/rpcs3/Emu/RSX/GL/glutils/state_tracker.hpp
@@ -366,15 +366,12 @@ namespace gl
 
 		GLuint get_bound_texture(GLuint layer, GLenum target)
 		{
-			ensure(layer < 48);
-			return bound_textures[layer][target];
+			return ::at32(bound_textures, layer)[target];
 		}
 
 		void bind_texture(GLuint layer, GLenum target, GLuint name, GLboolean force = GL_FALSE)
 		{
-			ensure(layer < 48);
-
-			auto& bound = bound_textures[layer][target];
+			auto& bound = ::at32(bound_textures, layer)[target];
 			if (bound != name || force)
 			{
 				glActiveTexture(GL_TEXTURE0 + layer);
diff --git a/rpcs3/util/media_utils.cpp b/rpcs3/util/media_utils.cpp
index d4f450ab69..51e7b9d5bf 100644
--- a/rpcs3/util/media_utils.cpp
+++ b/rpcs3/util/media_utils.cpp
@@ -347,9 +347,22 @@ namespace utils
 	{
 		if (!codec) return false;
 
-		for (const AVSampleFormat* p = codec->sample_fmts; p && *p != AV_SAMPLE_FMT_NONE; p++)
+		const void* sample_formats = nullptr;
+		int num = 0;
+
+		if (const int err = avcodec_get_supported_config(nullptr, codec, AVCodecConfig::AV_CODEC_CONFIG_SAMPLE_FORMAT, 0, &sample_formats, &num))
+		{
+			media_log.error("check_sample_fmt: avcodec_get_supported_config error: %d='%s'", err, av_error_to_string(err));
+			return false;
+		}
+
+		if (!sample_formats)
+			return true; // All supported
+
+		int i = 0;
+		for (const AVSampleFormat* fmt = static_cast<const AVSampleFormat*>(sample_formats); fmt && *fmt != AV_SAMPLE_FMT_NONE && i < num; fmt++, i++)
 		{
-			if (*p == sample_fmt)
+			if (*fmt == sample_fmt)
 			{
 				return true;
 			}
@@ -360,18 +373,33 @@ namespace utils
 	// just pick the highest supported samplerate
 	static int select_sample_rate(const AVCodec* codec)
 	{
-		if (!codec || !codec->supported_samplerates)
-			return 48000;
+		constexpr int default_sample_rate = 48000;
+
+		if (!codec)
+			return default_sample_rate;
+
+		const void* sample_rates = nullptr;
+		int num = 0;
+
+		if (const int err = avcodec_get_supported_config(nullptr, codec, AVCodecConfig::AV_CODEC_CONFIG_SAMPLE_RATE, 0, &sample_rates, &num))
+		{
+			media_log.error("select_sample_rate: avcodec_get_supported_config error: %d='%s'", err, av_error_to_string(err));
+			return default_sample_rate;
+		}
 
-		int best_samplerate = 0;
-		for (const int* samplerate = codec->supported_samplerates; samplerate && *samplerate != 0; samplerate++)
+		if (!sample_rates)
+			return default_sample_rate;
+
+		int i = 0;
+		int best_sample_rate = 0;
+		for (const int* sample_rate = static_cast<const int*>(sample_rates); sample_rate && *sample_rate != 0 && i < num; sample_rate++, i++)
 		{
-			if (!best_samplerate || abs(48000 - *samplerate) < abs(48000 - best_samplerate))
+			if (!best_sample_rate || abs(default_sample_rate - *sample_rate) < abs(default_sample_rate - best_sample_rate))
 			{
-				best_samplerate = *samplerate;
+				best_sample_rate = *sample_rate;
 			}
 		}
-		return best_samplerate;
+		return best_sample_rate;
 	}
 
 	AVChannelLayout get_preferred_channel_layout(int channels)
@@ -397,12 +425,25 @@ namespace utils
 	{
 		if (!codec) return nullptr;
 
+		const void* ch_layouts = nullptr;
+		int num = 0;
+
+		if (const int err = avcodec_get_supported_config(nullptr, codec, AVCodecConfig::AV_CODEC_CONFIG_CHANNEL_LAYOUT, 0, &ch_layouts, &num))
+		{
+			media_log.error("select_channel_layout: avcodec_get_supported_config error: %d='%s'", err, av_error_to_string(err));
+			return nullptr;
+		}
+
+		if (!ch_layouts)
+			return nullptr;
+
 		const AVChannelLayout preferred_ch_layout = get_preferred_channel_layout(channels);
 		const AVChannelLayout* found_ch_layout = nullptr;
 
-		for (const AVChannelLayout* ch_layout = codec->ch_layouts;
-			 ch_layout && memcmp(ch_layout, &empty_ch_layout, sizeof(AVChannelLayout)) != 0;
-			 ch_layout++)
+		int i = 0;
+		for (const AVChannelLayout* ch_layout = static_cast<const AVChannelLayout*>(ch_layouts);
+			 i < num && ch_layout && memcmp(ch_layout, &empty_ch_layout, sizeof(AVChannelLayout)) != 0;
+			 ch_layout++, i++)
 		{
 			media_log.notice("select_channel_layout: listing channel layout '%s' with %d channels", channel_layout_name(*ch_layout), ch_layout->nb_channels);
 
